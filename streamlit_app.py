import streamlit as st
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator
import io
from sklearn.preprocessing import MinMaxScaler
import seaborn as sns
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import dendrogram
from scipy.cluster import hierarchy
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
import numpy as np
from scipy.spatial import ConvexHull
from scipy.spatial.distance import cdist
import math


st.title('üíª –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–∞–π–ª–æ–≤ —ç–∫—Å–µ–ª—å')

st.info("–≠—Ç–æ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö, —Ö—Ä–∞–Ω—è—â–∏—Ö—Å—è –≤ —ç–∫—Å–µ–ª—å-—Ñ–∞–π–ª–∞—Ö")

with st.expander('–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö'):

  unploaded_file = st.file_uploader(label="–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Å–≤–æ–π —Ñ–∞–π–ª")

  if unploaded_file:
    # col_numbers = ["–í –¥–∞—Ç–∞—Å–µ—Ç–µ –Ω–µ—Ç –∫–æ–ª–æ–Ω–∫–∏ –¥–ª—è –∏–Ω–¥–µ–∫—Å–∞"] + [i for i in range (1,df.shape[1]+1)]
    col_index_change = st.selectbox("–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏—è", ["–í –¥–∞—Ç–∞—Å–µ—Ç–µ –Ω–µ—Ç –∫–æ–ª–æ–Ω–∫–∏ –¥–ª—è –∏–Ω–¥–µ–∫—Å–∞",
                                                                                         "–ò–Ω–¥–µ–∫—Å–æ–º –¥–∞—Ç–∞—Å–µ—Ç–∞ —è–≤–ª—è–µ—Ç—Å—è –ø–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü"])
    if col_index_change:
      if col_index_change == "–í –¥–∞—Ç–∞—Å–µ—Ç–µ –Ω–µ—Ç –∫–æ–ª–æ–Ω–∫–∏ –¥–ª—è –∏–Ω–¥–µ–∫—Å–∞":
        df = pd.read_excel(unploaded_file)
        df
      else:
        df = pd.read_excel(unploaded_file, index_col = 0)
        df

      
    # df = pd.read_excel(unploaded_file)
    # # df
    # col_titles = df.columns.values.tolist()
    # df.set_index(col_titles[1])
    # # col_titles
    # df
    
with st.expander('–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞—Ç–∞—Å–µ—Ç–∞'):
  if unploaded_file:
    st.header("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö")

    
    null_transform = st.selectbox("–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—É—Å—Ç—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö", ("–£–¥–∞–ª—è—Ç—å —Å—Ç—Ä–æ–∫–∏, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è", 
                                                                           "–ó–∞–º–µ–Ω—è—Ç—å –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞ –º–æ–¥—É –≤ –∫–æ–ª–æ–Ω–∫–µ"
                                                                          ))

    categorial_to_numerical = st.selectbox("–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ —á–∏—Å–ª–µ–Ω–Ω—ã–µ", ("–£–¥–∞–ª—è—Ç—å —Å—Ç—Ä–æ–∫–∏, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è", 
                                                                           "–ó–∞–º–µ–Ω—è—Ç—å –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞ —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –∫–æ–ª–æ–Ω–∫–µ",
                                                                           "–ó–∞–º–µ–Ω—è—Ç—å –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞ –º–æ–¥—É –≤ –∫–æ–ª–æ–Ω–∫–µ"
                                                                          ))

    
    if null_transform=="–£–¥–∞–ª—è—Ç—å —Å—Ç—Ä–æ–∫–∏, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è":
      df = df.dropna()
    else:
      for column in df.columns:
        df[column] = df[column].fillna(df[column].mode()[0])
  
    # col_index_categorical = st.selectbox("–í—ã–±–µ—Ä–∏—Ç–µ, –≤–∞—Ä–∏–∞–Ω—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—É—Å—Ç—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö", ("–£–¥–∞–ª—è—Ç—å —Å—Ç—Ä–æ–∫–∏, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è", 
    #                                                                        "–ó–∞–º–µ–Ω—è—Ç—å –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞ –º–æ–¥—É –≤ –∫–æ–ª–æ–Ω–∫–µ"
    #                                                                       ))
    # preparation_button = st.button("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å")
    # if preparation_button:
    #   st.write("–î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã")

  else:
    st.write('–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª –≤–æ –≤–∫–ª–∞–¥–∫–µ "–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö"')

# st.session_state["elbow_method_plot"] = None
# myplot = None


with st.expander('–ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–º k-means++'):
      
  if unploaded_file:
    if df.shape[0]>=3:
      elbow_method_need = st.selectbox("–¢—Ä–µ–±—É–µ—Ç—Å—è –ª–∏ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫ –ª–æ–∫—Ç—è –¥–ª—è –ª—É—á—à–µ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤?", ("–ù–µ—Ç", "–î–∞"), key="elbow_method_need_box")
      
      if elbow_method_need=="–î–∞":
        
        if df.shape[0]<=100:
          clusters_quan_elbow_method = st.selectbox("–£–∫–∞–∂–∏—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤",["–ù–µ –≤—ã–±—Ä–∞–Ω–æ"]+[i for i in range (3,df.shape[0]+1)], key = "clusters_quan_elbow_method_key")
        else:
          clusters_quan_elbow_method = st.selectbox("–£–∫–∞–∂–∏—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤",["–ù–µ –≤—ã–±—Ä–∞–Ω–æ"]+[i for i in range (3,100)], key = "clusters_quan_elbow_method_key")
    
        def elbow_method(df, max_clusters_quan):    
          # st.session_state.clicked = True
          ssd = []
          scaler = StandardScaler()
          scaled_df = scaler.fit_transform(df)
          for quan_of_clusters in range(2, max_clusters_quan+1):
              model = KMeans(n_clusters=quan_of_clusters, init="k-means++")
              model.fit(scaled_df)
              ssd.append(model.inertia_)
          plt.plot(range(2, max_clusters_quan+1), ssd, "o--")
          plt.title("–ì—Ä–∞—Ñ–∏–∫ –ª–æ–∫—Ç—è")
          plt.xlabel("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤")
          plt.ylabel("SSD")
          # Get the current axes
          ax = plt.gca()
          # Set x-axis to only display integers
          ax.xaxis.set_major_locator(MaxNLocator(integer=True))
          # st.session_state["elbow_plot"] = st.pyplot(plt)
          return st.pyplot(plt)



        # st.session_state["elbow_method_button_clicked"] 
        # def click_button():
          # myplot = elbow_method(df, clusters_quan_elbow_method)
        #   st.session_state["elbow_method_button_clicked"] = True
          # elbow_method(df, clusters_quan_elbow_method)
        
        if clusters_quan_elbow_method!="–ù–µ –≤—ã–±—Ä–∞–Ω–æ":
          elbow_method_button = st.button("–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫ –ª–æ–∫—Ç—è")

          if elbow_method_button:
            elbow_method(df, clusters_quan_elbow_method)

      if df.shape[0]<=100:
        k_means_cluster_quan = st.selectbox("–£–∫–∞–∂–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤",["–ù–µ –≤—ã–±—Ä–∞–Ω–æ"]+[i for i in range (3,df.shape[0]+1)], key="clusters_quan_k_plus_plus")
      else:
        k_means_cluster_quan = st.selectbox("–£–∫–∞–∂–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤",["–ù–µ –≤—ã–±—Ä–∞–Ω–æ"]+[i for i in range (3,100)], key="clusters_quan_k_plus_plus")
    
          
      def k_means_plus_plus(df, quan_of_clusters):
        try:
          scaler = StandardScaler()
          scaled_df = scaler.fit_transform(df)
          model = KMeans(n_clusters = quan_of_clusters, init = "k-means++")
          cluster_labels = model.fit_predict(scaled_df)
          df["–ù–æ–º–µ—Ä –∫–ª–∞—Å—Ç–µ—Ä–∞"] = cluster_labels
          st.session_state["current_df"] = df
          return df
                         
        except Exception as e:
          st.write(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ {e}")
          return None
          
      if k_means_cluster_quan!="–ù–µ –≤—ã–±—Ä–∞–Ω–æ": 
        df = k_means_plus_plus(df, k_means_cluster_quan)
        st.session_state["current_df"]
      # Create a Pandas Excel writer using XlsxWriter as the engine.
        buffer = io.BytesIO()
        
        with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
            # Write each dataframe to a different worksheet.
            st.session_state["current_df"].to_excel(writer, sheet_name='k_means')
        
            # Close the Pandas Excel writer and output the Excel file to the buffer
            writer.close()
        
            st.download_button(
                label="–ó–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞—Ç–∞—Ñ—Ä–µ–π–º –≤ —ç–∫—Å–µ–ª—å-—Ñ–∞–π–ª",
                data=buffer,
                file_name="dataframe_k_means_algorithm.xlsx",
                mime="application/vnd.ms-excel"
            )

    
            
    else:
      st.write("–í –¥–∞—Ç–∞—Å–µ—Ç–µ –º–µ–Ω—å—à–µ —Ç—Ä—ë—Ö —Å—Ç—Ä–æ–∫, –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –±–µ—Å—Å–º—ã—Å–ª–µ–Ω–Ω–∞. –£–≤–µ–ª–∏—á—å—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–¥–≥—Ç–æ–≤–∫–∏ –¥–∞—Ç–∞—Å–µ—Ç–∞, –µ—Å–ª–∏ –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ —Å—Ç—Ä–æ–∫ –±–æ–ª—å—à–µ")
  else:
    st.write('–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª –≤–æ –≤–∫–ª–∞–¥–∫–µ "–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö"')
    
with st.expander('–ò–µ—Ä–∞—Ä—Ö–∏—á–µ—Å–∫–∞—è –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è'):  
  if unploaded_file:
    if df.shape[0]>=3:
      st.write("–Ø –∑–¥–µ—Å—è!")

      def hierarchy_dendrogram(df, level=31):
        scaler = MinMaxScaler()
        scaled_data = scaler.fit_transform(df)
        scaled_df = pd.DataFrame(scaled_data, columns=df.columns)
        linkage_matrix = hierarchy.linkage(scaled_df.values, method="ward")
        # Create a figure and axis for the plot
        fig, ax = plt.subplots(figsize=(20, 10), dpi=200)
        ax.set_title("–î–µ–Ω–¥—Ä–æ–≥—Ä–∞–º–º–∞", fontsize=30)
        
        # Plot dendrogram on the provided axis
        dendrogram(linkage_matrix, truncate_mode="level", p=level-1, ax=ax)
        
        # Display the figure in Streamlit
        st.pyplot(fig)
        # plt.figure(figsize=(20,10), dpi=200)
        # plt.title(label="–î–µ–Ω–¥—Ä–æ–≥—Ä–∞–º–º–∞", fontsize=30)
        # dendro = dendrogram(linkage_matrix, truncate_mode="level", p=level-1)
        # st.pyplot()

        # fig, ax = plt.subplots(figsize=(20, 10), dpi=200)
        # ax.set_title("–î–µ–Ω–¥—Ä–æ–≥—Ä–∞–º–º–∞", fontsize=30)
        
        # Plot dendrogram on the provided axis
        # dendrogram(linkage_matrix, truncate_mode="level", p=level-1, ax=ax)
        # st.write([y[1] for y in dendrogram('dcoord')])
        
        # return [y[1] for y in dendrogram['dcoord']]
        
        
        # Display the figure in Streamlit
        # st.pyplot(fig)
        
        # plt.figure(figsize=(20,10), dpi=200)
        # plt.title(label="–î–µ–Ω–¥—Ä–æ–≥—Ä–∞–º–º–∞", fontsize=30)
        # dendro = dendrogram(linkage_matrix, truncate_mode="level", p=level-1)
        # fig, ax = plt.subplots()
        # st.pyplot(fig)
        return None

      dendrogram_need = st.selectbox("–¢—Ä–µ–±—É–µ—Ç—Å—è –ª–∏ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –¥–µ–Ω–¥—Ä–æ–≥—Ä–∞–º–º—É –¥–ª—è –ª—É—á—à–µ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤?", ("–ù–µ—Ç", "–î–∞"), key="dendrogram_need_box")
      
      if dendrogram_need=="–î–∞":
        if df.shape[0]<=100:
          dendrogram_level = st.selectbox("–í—ã–±–µ—Ä–∏—Ç–µ —É—Ä–æ–≤–µ–Ω—å –≥–ª—É–±–∏–Ω—ã –¥–µ–Ω–¥—Ä–æ–≥—Ä–∞–º–º—ã",["–ù–µ –≤—ã–±—Ä–∞–Ω–æ"]+[i for i in range (3,df.shape[0]+1)])
        else:
          dendrogram_level = st.selectbox("–í—ã–±–µ—Ä–∏—Ç–µ —É—Ä–æ–≤–µ–Ω—å –≥–ª—É–±–∏–Ω—ã –¥–µ–Ω–¥—Ä–æ–≥—Ä–∞–º–º—ã",["–ù–µ –≤—ã–±—Ä–∞–Ω–æ"]+[i for i in range (3,100)])
          
        if dendrogram_level!="–ù–µ –≤—ã–±—Ä–∞–Ω–æ":
          hierarchy_dendrogram(df, int(dendrogram_level))
           
      if df.shape[0]<=100:
        hierarchy_cluster_quan = st.selectbox("–£–∫–∞–∂–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤",["–ù–µ –≤—ã–±—Ä–∞–Ω–æ"]+[i for i in range(3, df.shape[0]+1)], key="clusters_quan_hierarchy")
        # hierarchy_cluster_quan = st.selectbox("–£–∫–∞–∂–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤",["–ù–µ –≤—ã–±—Ä–∞–Ω–æ"]+[i for i in range (3,df.shape[0]+1)], )
      # else:
        # hierarchy_cluster_quan = st.selectbox("–£–∫–∞–∂–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤",["–ù–µ –≤—ã–±—Ä–∞–Ω–æ"]+[i for i in range (3,100)], key="clusters_quan_hierarchy")
        
      def hierarchy_clusterisation(df, quan_of_clusters):
        scaler = MinMaxScaler()
        scaled_data = scaler.fit_transform(df)
        scaled_df = pd.DataFrame(scaled_data, columns=df.columns)
        model = AgglomerativeClustering(quan_of_clusters)
        cluster_labels = model.fit_predict(scaled_df)
        df["–ù–æ–º–µ—Ä –∫–ª–∞—Å—Ç–µ—Ä–∞"] = cluster_labels
        st.session_state["current_df"] = df
        return df

      if hierarchy_cluster_quan!="–ù–µ –≤—ã–±—Ä–∞–Ω–æ": 
        df = hierarchy_clusterisation(df, hierarchy_cluster_quan)
        st.session_state["current_df"]
      # Create a Pandas Excel writer using XlsxWriter as the engine.
        buffer = io.BytesIO()
        
        with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
            # Write each dataframe to a different worksheet.
            st.session_state["current_df"].to_excel(writer, sheet_name='k_means')
        
            # Close the Pandas Excel writer and output the Excel file to the buffer
            writer.close()
        
            st.download_button(
                label="–ó–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞—Ç–∞—Ñ—Ä–µ–π–º –≤ —ç–∫—Å–µ–ª—å-—Ñ–∞–π–ª",
                data=buffer,
                file_name="dataframe_hierarchy_algorithm.xlsx",
                mime="application/vnd.ms-excel"
            )
      
    else:
      st.write("–í –¥–∞—Ç–∞—Å–µ—Ç–µ –º–µ–Ω—å—à–µ —Ç—Ä—ë—Ö —Å—Ç—Ä–æ–∫, –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –±–µ—Å—Å–º—ã—Å–ª–µ–Ω–Ω–∞. –£–≤–µ–ª–∏—á—å—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–¥–≥—Ç–æ–≤–∫–∏ –¥–∞—Ç–∞—Å–µ—Ç–∞, –µ—Å–ª–∏ –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ —Å—Ç—Ä–æ–∫ –±–æ–ª—å—à–µ")
  else:
    st.write('–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª –≤–æ –≤–∫–ª–∞–¥–∫–µ "–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö"')

with st.expander('–ú–µ—Ç–æ–¥ DBSCAN'):  
  if unploaded_file:
    if df.shape[0]>=3:
      st.write("–Ø —Ç—É—Ç–∞!")
      
      # dbscan = DBSCAN()

      epsilon_def_state = st.selectbox("–¢—Ä–µ–±—É–µ—Ç—Å—è –ª–∏ –ø–æ–º–æ—â—å –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —ç–ø—Å–∏–ª–æ–Ω?", ["–ù–µ—Ç", "–î–∞"])
      if epsilon_def_state == "–î–∞":
        points = df.values
        hull = ConvexHull(points)
        hullpoints = points[hull.vertices,:]
        longest_dist = cdist(hullpoints, hullpoints, metric='euclidean').max()

        def distance(p1, p2):
          return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

# Function to find the minimum distance in the strip
        def stripClosest(strip, d):
            min_dist = d
        
            # Sort points in the strip by their y-coordinate
            strip.sort(key=lambda point: point[1])
        
            # Compare each point in the strip
            for i in range(len(strip)):
                for j in range(i + 1, len(strip)):
                    if (strip[j][1] - strip[i][1]) < min_dist:
                        min_dist = min(min_dist, distance(strip[i], strip[j]))
                    else:
                        break
        
            return min_dist
        
        # Divide and conquer function to find the minimum distance
        def minDistUtil(points, left, right):
            
            # Base case brute force for 2 or fewer points
            if right - left <= 2:
                min_dist = float('inf')
                for i in range(left, right):
                    for j in range(i + 1, right):
                        min_dist = min(min_dist, distance(points[i], points[j]))
                return min_dist
        
            # Find the midpoint
            mid = (left + right) // 2
            mid_x = points[mid][0]
        
            # Recursively find the minimum distances
            # in the left and right halves
            dl = minDistUtil(points, left, mid)
            dr = minDistUtil(points, mid, right)
        
            d = min(dl, dr)
        
            # Build the strip of points within distance d from the midl
            strip = []
            for i in range(left, right):
                if abs(points[i][0] - mid_x) < d:
                    strip.append(points[i])
        
            # Find the minimum distance in the strip
            stripDist = stripClosest(strip, d)
        
            return min(d, stripDist)
        
        # Function to find the closest pair of points
        def minDistance(points):
            n = len(points)
        
            # Sort points by x-coordinate
            points.sort(key=lambda point: point[0])
        
            return minDistUtil(points, 0, n)

        st.write("lalalala")
    
    else:
      st.write("–í –¥–∞—Ç–∞—Å–µ—Ç–µ –º–µ–Ω—å—à–µ —Ç—Ä—ë—Ö —Å—Ç—Ä–æ–∫, –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –±–µ—Å—Å–º—ã—Å–ª–µ–Ω–Ω–∞. –£–≤–µ–ª–∏—á—å—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–¥–≥—Ç–æ–≤–∫–∏ –¥–∞—Ç–∞—Å–µ—Ç–∞, –µ—Å–ª–∏ –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –¥–∞—Ç–∞—Å–µ—Ç–µ —Å—Ç—Ä–æ–∫ –±–æ–ª—å—à–µ")
  else:
    st.write('–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª –≤–æ –≤–∫–ª–∞–¥–∫–µ "–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö"')

  

    



